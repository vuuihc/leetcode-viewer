{"javascript":"/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n/**\r\n * @param {ListNode[]} lists\r\n * @return {ListNode}\r\n */\r\nvar mergeKLists = function(lists) {\r\n    var MinHeap = function(){\r\n        this.arr = [null];\r\n    };\r\n    MinHeap.prototype.min = function(){\r\n        return this.arr[1];\r\n    }\r\n    MinHeap.prototype.pop = function(){//从堆中取出最值\r\n        if(this.arr.length<2) return;//如果堆是空的，返回\r\n        if(this.arr.length===2) return this.arr.pop();//如果只有根节点了，返回\r\n        let r = this.arr[1];//暂存最值\r\n        this.arr[1] = this.arr.pop();//把树中最后一个结点放到根节点上\r\n        let index = 1;\r\n        while(2*index<this.arr.length){//下沉操作，如果还有子节点，就将index节点与当前节点比较，保证根节点到底部保持大小关系（堆的定义）\r\n            let child = 2*index;\r\n            if(child+1 < this.arr.length && this.arr[child+1].val < this.arr[child].val){\r\n                child++;\r\n            }\r\n            if(this.arr[index].val <= this.arr[child].val){\r\n                break;\r\n            }\r\n            let temp = this.arr[index];\r\n            this.arr[index] = this.arr[child];\r\n            this.arr[child] = temp;\r\n            temp = null;\r\n            index = child;\r\n        }\r\n        return r;\r\n    }\r\n    MinHeap.prototype.add = function(node){//入堆操作\r\n        this.arr.push(node);//把新节点加到底部\r\n        bubble.call(this,this.arr.length-1);//进行上浮操作\r\n        function bubble(index){\r\n            let self = this;\r\n            while(index>1){\r\n                let parent = Math.floor(index/2);\r\n                if(self.arr[parent].val <= self.arr[index].val){\r\n                    break;\r\n                }\r\n                let temp = self.arr[parent];\r\n                self.arr[parent] = self.arr[index];\r\n                self.arr[index] = temp;\r\n                index = parent;\r\n            }\r\n        }\r\n    }\r\n    MinHeap.prototype.isEmpty = function(){\r\n        return this.arr.length === 1;\r\n    }\r\n    MinHeap.prototype.print = function(){\r\n        console.log(this.arr);\r\n    }\r\n    let head = new ListNode(),\r\n        tail=head,\r\n        heap = new MinHeap();\r\n    for(let list of lists){//把每一个非空链表的头部入堆\r\n        if(list!==null){\r\n            heap.add(list);\r\n        }\r\n    }\r\n    // console.log(heap.isEmpty());\r\n    while(!heap.isEmpty()){//出堆，把出堆节点的下一个节点（如果有）入堆\r\n        tail.next = heap.pop();\r\n        tail = tail.next;\r\n        if(tail.next!==null){\r\n            heap.add(tail.next);\r\n        }\r\n    }\r\n    return head.next;\r\n};"}